# [백준2636번] 치즈 / Python3

## 문제

아래 <그림 1>과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다. 판의 가장자리(<그림 1>에서 네모 칸에 X친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다.

이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다. 치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다. <그림 1>의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후에 녹아 없어져서 <그림 2>와 같이 된다.

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/BPOxvQj6Ys.jpg)

다시 한 시간 후에는 <그림 2>에서 ‘c’로 표시된 부분이 녹아 없어져서 <그림 3>과 같이 된다.

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/e3BJaDrJjITZ.png)

<그림 3>은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다. 그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다. <그림 3>과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다.

입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때, 공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 사각형 모양 판의 세로와 가로의 길이가 양의 정수로 주어진다. 세로와 가로의 길이는 최대 100이다. 판의 각 가로줄의 모양이 윗 줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어지며 각 숫자 사이에는 빈칸이 하나씩 있다.

## 출력

첫째 줄에는 치즈가 모두 녹아서 없어지는 데 걸리는 시간을 출력하고, 둘째 줄에는 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 출력한다.

## 예제 입력 1

```
13 12
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 0 0 0
0 1 1 1 0 0 0 1 1 0 0 0
0 1 1 1 1 1 1 0 0 0 0 0
0 1 1 1 1 1 0 1 1 0 0 0
0 1 1 1 1 0 0 1 1 0 0 0
0 0 1 1 0 0 0 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 1

```
3
5
```

<br>

## 나의 풀이

> 해당 문제는 BFS를 활용하는 문제였다.
>
> 주어지는 판의 양끝 행과 열이 모두 비어있다는 것이 전제로 주어져있다. 따라서 처음 `[0,0]`을 시작으로 BFS를 돌리면 문제에서 말하는 구멍으로는 접근이 불가능하다는 것을 캐치하면 문제는 아주 쉽게 풀 수 있을 것이다. 
>
> 우선 한번의 BFS마다 `[0][0]`에서 시작해서 상하좌우를 확인하여 공기(즉,`0`)이면 큐에 넣어 계속 탐색을 시작한다. 그러다 치즈(즉, `1`)을 만나면 치즈를 0으로 바꾸고 방문처리를 해준다. 이렇게 각 BFS마다 없어지는 치즈의 개수를 카운트하고 반환값으로 돌려준다. 이렇게 반환되는 카운트가 0이 될때까지 BFS를 반복하며 각 단계별로 없어지는 치즈의 개수를 배열에 담아주었다. 또한 BFS를 반복할때마다 time을 카운트해주었다. 이렇게 해주면 문제에서 원하는 모두 녹는데까지의 시간과 다 녹기 직전의 치즈 개수도 구할 수 있다.

<br>

```python
# 2636번 치즈
from collections import deque

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]
def find_air():
    visited = [[False] * c for _ in range(r)]

    q = deque()
    q.append([0, 0])
    visited[0][0] = True
    cnt = 0
    while q:
        y, x = q.popleft()

        for i in range(4):
            ny = y + dy[i]
            nx = x + dx[i]
            if 0 <= ny < r and 0 <= nx < c and not visited[ny][nx]:
                if board[ny][nx] == 0:
                    visited[ny][nx] = True
                    q.append([ny, nx])
                elif board[ny][nx] == 1:
                    board[ny][nx] = 0
                    cnt += 1
                    visited[ny][nx] = True
    cheese.append(cnt)
    return cnt
                
r, c = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(r)]
cheese = []

time = 0
while True:
    time += 1
    cnt = find_air()
    if cnt == 0:
        break

print(time-1)
print(cheese[-2])

```

