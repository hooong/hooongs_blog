# [백준1389번] 케빈 베이컨의 6단계 법칙 / Python3

## 문제

케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.

예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?

천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.

케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.

오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.

예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.

1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.

2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.

3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.

4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.

마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.

5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.

BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.

 

## 입력

첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다.

## 출력

첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.

## 예제 입력 1

```
5 5
1 3
1 4
4 5
4 3
3 2
```

## 예제 출력 1

```
3
```

<br>

## 나의 풀이

> 처음에 이 문제를 보고 DFS를 사용해 각 정점에서 모든 정점으로의 최단 거리를 구하여 즉, 다익스트라를 사용하여 문제를 풀이했더니 시간초과가 나왔다. 밑을 보니 플로이드-와샬 알고리즘을 사용하여야 된다는 것을 알았다. 그래서 검색을 통해 플로이드-와샬 알고리즘에 대하여 학습을 했다. 
>
> <br>
>
> #### 플로이드-와샬 알고리즘
>
> ```
>  한 점에서 모든 점으로 가는 최단경로를 구하는 다익스트라와는 다르게 플로이드-와샬은 모든 최단경로를 구하는 알고리즘이다. 플로이드-와샬 알고리즘은 optimal substructure의 개념을 이용하는데 이는 특정 정점으로 가는 수많은 경로 중 어떠한 중간 지점을 거쳐가는 것이 최단경로라면 그 최단경로를 이용하면 특정 정점으로 가는 최단경로가 된다는 것이다. 이 알고리즘도 다익스트라와는 다르게 음수의 가중치를 다룰 수 있다. (단, 음수에 순환이 없는 경우) 그리고 이 알고리즘의 시간복잡도는 O(V^3)으로 매우 크다. 하지만 꼭 사용해야할 상황들이 존재한다고 한다.
>  플로이드-와샬의 기본 로직은 우선 i에서 j로 가는 최단 거리를 담는 2차원 배열에 k정점을 거쳐 지나갈때 최단경로가 되는지를 확인해 나가는 것이다. 앞에서 시간복잡도가 O(V^3)이라고 했다. 이것은 바로 k에 대하여 반복, i에 대하여 반복, j에 대하여 반복하는데 각 반복에서 정점의 개수인 V에서 자기 자신을 제외한 (V-1)번을 반복하기 때문이다. 따라서 플로이드-와샬을 처음으로 k(중간지점)에 대하여 반복을 하면서 i(출발지점)에서 j(도착지점)으로 가는 모든 경우에 거리를 비교해나가면서 최솟값을 저장해나가는 것이다. 
> ```
>
> <br>
>
> 위에서 플로이드-와샬 알고리즘에 대하여 간단히 설명을 하였다. 이제 이 문제의 해결법을 보겠다. 우선 각 최단거리를 담을 2차원 배열을 선언해준다. 그 후 초기화를 진행해야한다. 초기화는 입력에서 관계로 주어지는 것으로 1과 2가 아는 사이라는 것은 정점1과 정점2가 인접했다는 뜻이다. 따라서 2차원 배열에서 `[1][2]` ,`[2][1]` 의 요소를 1로 초기화를 해주는 것이다. 또한 처음에 인접하지 않은 곳의 값은 `INF` 로 설정을 해준다. 
>
> ![IMG_403153A680A8-1](https://user-images.githubusercontent.com/37801041/78419508-5f4d9480-7681-11ea-891b-2b26d12ab345.jpeg)
>
> <br>
>
> 그리고나서는 중간 지점 k에 대하여 반복을 하면서 각 반복에서 i~j의 경로의 거리와 k를 거쳐갈때의 거리를 비교해서 더 작은 값으로 최신화를 시켜주면 된다. 이것을 점화식으로 정리하면 다음과 같다. 
>
> `d[i][j] = min(d[i][j] ,d[i][k] + d[k][j])`
>
> 이후 각 노드에 대하여 최단 거리를 모두 구하여 케빈 베이컨 수를 구하였다. 여기서 필자는 플로이드-와샬 알고리즘을 돌릴때 자기 자신을 빼지 않았다. 그리고 케빈 베이컨 수를 구할때도 자기 자신을 포함해서 더했다. 이 문제에서는 친구가 한 명도 없는 사람은 없다고 가정을 했다. 이 말은 어느 정점도 인접하지 않은 정점이 없다는 말이다. 또 다시말해 자기 자신으로 다시 돌아오는 최단 거리는 무조건 2가 된다는 말과 같다. 따라서 이 문제에 한해서는 자기 자신을 생각하지 않아도 풀 수 있다는 말이다.
>
> <br>
>
> 필자는 처음에 다른 dp문제들을 생각하고 i, j, k 순으로 반복을 했었다. 그런데 우연히 이 문제의 예제는 정답이 맞았는데 채점을 하니 틀렸다고나왔다. 자세히보니 k에 대하여 먼저 반복을 했던 것이다. 잘 생각해보니 중간 지점을 크게 반복을 해주고 이 중간 지점에 대하여 i와 j의 경로를 비교해야 제대로 된 최단경로가 구해진다는 것을 알아챘다... 혹시나 필자와 같은 실수를 한다면 이것을 확인해보는게 좋을 것 같다.

<br>

## 코드

```python
# 1389번 케빈 베이컨의 6단계 법칙
import sys
INF = float('inf')

# main
N, M = [int(x) for x in sys.stdin.readline().split()]

# 각 관계에 대하여 최단 거리를 저장
relation = [[INF for _ in range(N)] for _ in range(N)]

for _ in range(M):
    x, y = [int(x) for x in sys.stdin.readline().split()]

    # 테이블 초기화 (인접한 정점과의 거리)
    relation[x-1][y-1] = 1
    relation[y-1][x-1] = 1

# 플로이드-와샬 알고리즘
for k in range(N):      # 한 점을 경유
    for i in range(N):      # i에서 출발
        for j in range(N):  # j로 도착
            relation[i][j] = min(relation[i][j], relation[i][k] + relation[k][j])

print(relation)
# 케빈 베이컨 수
kebin = []
for i in range(N):
    dSum = 0
    for j in range(N):
        dSum += relation[i][j]
    kebin.append(dSum)

print(kebin.index(min(kebin)) + 1)

```



