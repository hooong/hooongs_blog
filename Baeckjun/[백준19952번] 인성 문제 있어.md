# [백준19952번] 인성 문제 있어??

## 문제

인성이는 인싸가 되기 위해서 인싸트 특별과정에 참가했다. 훈련 첫날 인성이는 험난한 미로에서 목적지에 도달해야 하는 훈련을 받고 있다. 제한 시간 안에 미로를 통과하지 못하면 명기 교관 님에게 욕을 듣기에 인성이는 최선을 다해 미로를 통과하려고 한다.

미로는 가로 길이 *W*, 세로 길이 *H*의 격자 형태를 가지며, 인성이는 한 번에 격자 상의 상, 하, 좌, 우로 한칸 씩 움직일 수 있다. 매 이동이 완료될 시에 인성이의 남은 힘은 1씩 감소하고, 남은 힘이 0이하인 경우에는 더 이상 움직이지 못하게 된다.

미로의 각 격자에는 장애물이 있는데, 각각의 장애물은 높이 정보를 가지고 있다. 장애물이 없는 위치는 전부 높이가 0 이다. 인성이가 이동할 때, 현재 위치보다 이동할 위치의 높이가 더 낮으면 아무런 제약을 갖지 않고 이동할 수 있다. 더 높은 곳으로 이동할 때는 점프를 할 수 있는데, 점프해야 하는 높이는 (이동할 곳의 높이 - 현재 위치한 곳의 높이) 이다. 이때 남아있는 힘이 점프해야 하는 높이보다 크거나 같으면 이동할 수 있고, 그렇지 않으면 이동하지 못한다.

인성이는 신체적 한계를 극복하고 무사히 목적지에 도달해서 명기 교관님의 욕설을 듣지 않을 수 있을까?

## 입력

첫째 줄에 테스트 케이스 *T*가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다.

첫째 줄에 미로의 세로길이 *H*, 가로길이 *W*, 장애물의 개수 *O*, 초기 힘 *F,* 출발지의 좌표 정보 *Xs*(행), *Ys*(열)목적지의 좌표정보 *Xe*(행), *Ye(*열) 가 주어진다.

둘째 줄부터 *O*개의 줄에 장애물의 좌표 정보 *X*(행), *Y*(열) 와 높이 정보 *L이* 주어진다. 모든 장애물은 서로 다른 위치에 존재한다.

## 출력

*T*개의 줄에 인성이가 목적지에 도착할 수 있을 때 "잘했어!!", 목적지에 도착할 수 없을 때 "인성 문제있어??" 를 출력한다.

## 제한

- 1 ≤ *T* ≤ 10
- 2 ≤ *H, W* ≤ 100
- 0 ≤ *O* ≤ H x W
- 0 ≤ *F* ≤ 10,000, *F* 는 정수이다.
- 1 ≤ *L* ≤ 50, *L*은 정수이다.
- 1 ≤ *X*, *Xs*, *Xe* ≤ *H*
- 1 ≤ Y*,* *Ys*, *Ye* ≤ *W*
- 시작 위치와 목적지에는 장애물이 존재하지 않는다.

## 예제 입력 1 복사

```
1
3 3 7 5 1 1 3 3
1 2 4
1 3 8
2 1 1
2 2 2
2 3 4
3 1 8
3 2 4
```

## 예제 출력 1 복사

```
잘했어!!
```

## 예제 입력 2 복사

```
1
3 5 3 6 1 1 3 5
1 2 8
2 1 8
3 1 4
```

## 예제 출력 2 복사

```
인성 문제있어??
```

<br>

## 나의 풀이

> 전형적인 BFS 문제였다. 메모리 초과를 방지하기 위해서 visited라는 방문 여부를 저장하는 배열과 `(이동할 곳의 높이 - 현재 위치한 곳의 높이)`가 남아있는 힘보다 작거나 같은지를 비교하여 큐에 넣어주면서 BFS를 진행하면 되는 문제로 딱히 어렵지는 않은 문제였다. 참고로 DFS로 백트래킹을 한다면 시간초과가 발생한다.

<br>

## 코드

```python
# 19952번 인성 문제 있어?
from collections import deque

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]

t = int(input())

for _ in range(t):
    h, w, o, f, xs, ys, xe, ye = map(int, input().split())
    board = [[0] * w for _ in range(h)]
    visited = [[False] * w for _ in range(h)]
    visited[xs-1][ys-1] = True

    for _ in range(o):
        x, y, l = map(int, input().split())
        board[x-1][y-1] = l

    is_success = False
    dq = deque()
    dq.append([xs-1, ys-1, f])

    while dq:
        cur_x, cur_y, cur_f = dq.popleft()
        
        if cur_x == xe - 1 and cur_y == ye - 1:
            is_success = True
            break

        if cur_f == 0:
            continue
        
        for i in range(4):
            nx = cur_x + dx[i]
            ny = cur_y + dy[i]

            if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny]:
                if (board[nx][ny] - board[cur_x][cur_y]) <= cur_f:
                    visited[nx][ny] = True
                    dq.append([nx, ny, cur_f-1])

    if is_success:
        print("잘했어!!")
    else:
        print("인성 문제있어??")

```

