# [백준1080번] 행렬 / Python3

## 문제

0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.

행렬을 변환하는 연산은 어떤 3*3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 -> 1, 1 -> 0)

## 입력

첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.

## 출력

첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.

## 예제 입력 1

```
3 4
0000
0010
0000
1001
1011
1001
```

## 예제 출력 1 

```
2
```

<br>

## 나의 풀이

> 그리디 문제로 이러한 경우 어떤게 그리디한건지부터 생각을 해보았다. 생각을 하다가 그냥 직감적인 느낌으로 `[0][0]`부터  B의 행렬과 다르다면 `[0][0]` 부터 시작하는 `3*3` 크기만큼을 뒤집어보며 범위내의 모든 경우를 차례대로 뒤집어보는 것이었다. 물론 정답이었다. 
>
> <br>
>
> 다시말해 그냥 처음 원소부터 `0 ~ n-3`, `0 ~ m-3`범위의 원소들을 B의 원소와 확인을 하고 다르다면 `3*3`크기 만큼 뒤집는 것이다. 이렇게하면 `[0][0]`원소는 B와 같아지게 되고 이후 차례대로 움직이면 `[0][0]`의 원소는 다시는 뒤집어지지 않게되고 확실히 B와 같다는 것이 보장이 되기때문이다. 따라서 이렇게 범위내의 모든 원소를 확인하면 `3*3`크기를 뒤집이가면서 확인해 볼 수 있는 경우를 모두 확인하는 것이다. 
>
> <br>
>
> 주의할 점은 n과 m이 3보다 작은 입력도 주어진다는 것이다. 처음에 이것을 고려하지 않아서 위에서 생각한 알고리즘이 틀린 줄 알았다... 하지만 n과 m, 둘 중에 하나라도 3보다 작은 수가 입력으로 주어진다면 원소를 뒤집는 행동자체를 할 수없기때문에 B와 같다면 `0`을 출력하고 그렇지 않다면 `-1`을 출력해주어야 한다는 것을 생각해주어야했다.

<br>

## 코드

```python
# 1080번 행렬
import sys

# flip
def flip(y,x):
    global matA

    for i in range(3):
        for j in range(3):
            if matA[y+i][x+j] == '0':
                matA[y+i][x+j] = '1'
            else:
                matA[y+i][x+j] = '0' 

# main
n, m = map(int, input().split())

matA = []
matB = []
for _ in range(n):
    matA.append(list(sys.stdin.readline().strip()))

for _ in range(n):
    matB.append(list(sys.stdin.readline().strip()))

cnt = 0
if n < 3 or m < 3:
    if matA == matB:
        print(cnt)
        exit(0)

for i in range(n-2):
    for j in range(m-2):
        if not matA[i][j] == matB[i][j]:
            flip(i,j)
            cnt += 1

        if matA == matB:
            print(cnt)
            exit(0)

print(-1)
        
```

