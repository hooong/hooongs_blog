# [Server] Apache Reverse Proxy 구현

이번 글에서는 Apache가 제공하는 `mod_proxy` 모듈을 사용해 리버스 프록시를 구현해보려고 합니다. 프록시에 대해서 모든 것을 설명하기에는 벅차기 때문에 이번 글에서는 간단히 프록시가 무엇이고, 포워드 프록시와 리버스 프록시의 차이점에 대해서만 설명해보려고 합니다.

<br>

## 프록시란?

프록시 서버는 서버와 클라이언트 사이에 위치하여 요청이나 응답을 중계하는 역할을 하는 서버라고 할 수 있습니다. 다시 말하면 클라이언트에서 보내는 요청을 프록시 서버에서 대신 처리하게끔하여 일종의 대리인이 될 수도 있습니다. 즉, 아래 그림과 같이 클라이언트에서 요청을 보내면 프록시 서버가 중간에 위치하여 요청에 대하여 검증을 한다거나 부가적인 작업을 수행할 수 있게됩니다.

<img align="center" src="https://user-images.githubusercontent.com/37801041/104838706-08f3ce80-5900-11eb-89fd-f9271714cc0c.png" width=700>

<br>

## 포워드 프록시? 리버스 프록시?

어찌됐든 프록시 서버가 클라이언트와 서버 사이에서 무언가를 해서 중계를 해준다는 것을 알게되었습니다. 그럼 포워드 프록시와 리버스 프록시에 대하여 간단하게 살펴보겠습니다. 포워드 프록시과 리버스 프록시는 서버의 위치에 따라 구분하게 됩니다.

#### 포워드 프록시 (Forward Proxy)

포워드 프록시는 클라이언트와 서버 사이에서 클라이언트의 요청을 받아 대신 서버에게 결과를 받고 그 결과를 클라이언트에게 전달해주는 역할을 하게됩니다. 즉, 내부망에서 인터넷으로 나가기 직전에 위치하는 프록시 서버라고 할 수 있습니다. 그렇기때문에 포워드 프록시의 End Point는 클라이언트가 요청하는 실제 서버의 도메인이 됩니다. 그리고 프록시가 클라이언트의 요청을 대리 수행하기 때문에 클라이언트의 정보가 감춰지며 요청을 받는 서버는 클라이언트의 정보에 대해 알 수 가 없습니다.

<img align="center" src="https://user-images.githubusercontent.com/37801041/104839231-08106c00-5903-11eb-83bb-1c720e5c8f30.png" width=600>

따라서, 대개 포워드 프록시는 캐싱 기능을 가지기 때문에 불필요한 연결을 하지 않게끔하여 비용을 절약하기위해 사용하며 또는 기업에서 웹 사용 환경을 제한하기 위해서도 사용을 합니다.

#### 리버스 프록시 (Reverse Proxy)

리버스 프록시는 인터넷에서 내부망으로 들어오기 직전에 위치하게 됩니다. 포워드 프록시의 내부망에서 나가기 직전에 위치하는 것과는 반대의 개념으로 생각할 수 있습니다. 즉, 클라이언트는 리버스 프록시에게 요청을 보내고 리버스 프록시는 이 요청을 내부망에 있는 서비스 서버와 통신을 하는 방식을 취하게 됩니다. 이렇게 사용하는 이유는 보안적인 이유가 가장 큽니다. 예를들어, 내부망으로 들어오는 특정 IP주소를 막는다거나 할 수 있습니다. 또, 리버스 프록시는 로드밸런싱을 구현할 수 있습니다. 로드밸런싱은 부하 분산 기능이라하며 사용자의 요청을 균등하게 배분하는 기능입니다. 이 기능을 통해 한 서버로 요청이 몰려 서버가 죽는다거나 느려지는 현상을 대비할 수 있습니다.

<img align="center" src="https://user-images.githubusercontent.com/37801041/104839609-8bcb5800-5905-11eb-8e61-5c0e28f5b3fe.png" width=600>

따라서, 리버스 프록시의 End Point는 클라이언트가 요청하는 프록시 서버의 도메인이 되며, 클라이언트의 입장에서 요청을 하는 실제 서버에 대한 정보를 알 수가 없게됩니다.

<br>

## mod_proxy 사용하기

위에서 간단하게 프록시에 대하여 알아보았습니다. 이제는 Apache가 제공하는 `mod_proxy` 모듈을 사용하여 리버스 프록시 서버를 구성해보고 부하 분산 기능도 구현을 해보고자 합니다. `mod_proxy` 모듈은 Apache의 내장 모듈로 httpd 패키지를 설치하면 기본적을 사용 가능합니다. 

### proxy 설정

```shell
# 프록시 서버에 대한 설정 파일 생성
$ vi /etc/httpd/conf.d/proxy.conf

1 <IfModule mod_proxy.c>
2        proxyRequests Off
3        <Proxy *>
4                Require all granted
5        </Proxy>
6        ProxyPass / http://www.naver.com/
7        ProxyPassReverse / http://www.naver.com/
11 </IfModule>

# httpd 재실행
$ systemctl restart httpd
```

리버스 프록시는 대개 내부망으로 연결을 하지만 이번 실습에서는 해당 프록시 서버로 들어오는 요청에 대해서 네이버로 요청을 보내는 실습을 해보았습니다. 

> 2 : 이 프록시를 포워드가 아닌 리버스 기능을 위해 사용할 경우 off로 설정해야함.
>
> 4 : 모든 네트워크에서의 접속을 혀용하는 접근 제어 지시어
>
> 6 : `/` 로 들어오는 요청을 `www.naver.com` 으로 보낸다는 의미
>
> 7 : 클라이언트가 우회해서 이 리버스 프록시 된 웹사이트로 접속하는 것을 방지하기 위해 응답 헤더의 정보에서 `www.naver.com` 을 모두 `/` 에 해당하는 주소로 변경하라는 의미

위와 같이 설정을 하고 해당 서버주소로 접속을 하면 네이버로 접속이 되는 것을 확인해 볼 수 있습니다.

<br>

## 부하 분산 기능

Apache의 `mod_proxy`모듈은 요청을 분산시키는 부하 분산 기능을 제공합니다. 그 기능을 사용하는 방법에 대하여 살펴봅시다.

```shell
# 프록시 서버에 대해 부하 분산을 설정하기 위한 수정
$ vi /etc/httpd/conf.d/proxy.conf

1 <IfModule mod_proxy.c>
2        proxyRequests Off
3        <Proxy *>
4                Require all granted
5        </Proxy>
6        ProxyPass / balancer://mycluster lbmethod=byrequests
7        <proxy balancer://mycluster>
8                BalancerMember http://www.naver.com/ loadfactor=1
9                BalancerMember http://www.google.com/ loadfactor=1
10       </proxy>
11 </IfModule>

# httpd 재실행
$ systemctl restart httpd
```

> 6 : `/` 의 요청에 대한 balancer를 지정해주고 `lbmethod` 는 요청을 분산시키는 방법을 지정하는 옵션으로 `byrequests` 즉, 클라이언트의 요청 수에 따라로 설정을 해줍니다.
>
> 7 : 6번에서 지정한 balancer를 정의합니다. 여기서는 `www.naver.com`과 `www.google.com`을 설정하였고, `loadfactor`를 각각 1로 설정해줍니다. 둘다 1로 설정이되어 50대 50으로 각각 50%씩으로 분산을 시키라는 의미가 됩니다.

위와 같이 `www.naver.com`과 `www.google.com`을 각각 비율을 1로 설정하였기 때문에 2개의 요청이 들어온다면 하나는 네이버로 하나는 구글로 접속이 될 것입니다. 이렇게 네이버나 구글이 아닌 내부망의 서비스 서버로 설정을 하게 된다면 요청의 부하를 분산시킬 수 있게됩니다.

<br>

## 정리하며...

이번 글에서는 프록시에 대하여 간단하게 알아보고 Apache에서 모듈을 사용하여 리버스 프록시를 구성해보고 이를 사용해 부하 분산 기능도 구현을 해보는 시간을 가졌습니다. 설명이 부족할 수도 있고 제가 잘못 이해한 부분이 있을수도 있습니다. 혹시 잘못된 내용이 있거나 한다면 댓글을 통해 알려주시면 감사하겠습니당~^^. 여기까지 읽어주셔서 감사합니다!

